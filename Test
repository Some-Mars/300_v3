#include <gtest/gtest.h>

// Подключаем функции из основного кода
double recur(vector<vector<double>>& C, double dT, double h, int n, int j);
void solveEquationMPI(double dT, double h, double x_0, double x_n, double t_0, double t_n, int size, vector<vector<double>>& C);

// Тест для проверки начального условия
TEST(InitialConditionTest, CheckInitialCondition) {
    double dT = 0.1;
    double h = 0.1;
    double x_0 = 0;
    double x_n = 1;
    double t_0 = 0;
    double t_n = 0;

    int x_nums = int((x_n - x_0) / h);
    int N = int((t_n - t_0) / dT);

    vector<vector<double>> C(N + 1, vector<double>(x_nums + 1));

    // Запускаем функцию для решения уравнения
    solveEquationMPI(dT, h, x_0, x_n, t_0, t_n, 1, C);

    // Проверяем, что начальное условие c(0, x) = sin(x) + 1 правильно установлено
    for (int i = 0; i <= x_nums; i++) {
        ASSERT_DOUBLE_EQ(C[0][i], sin(x_0 + h * i) + 1.0);
    }
}

// Тест для проверки граничного условия
TEST(BorderConditionTest, CheckBorderCondition) {
    double dT = 0.1;
    double h = 0.1;
    double x_0 = 0;
    double x_n = 0;
    double t_0 = 0;
    double t_n = 1;

    int x_nums = int((x_n - x_0) / h);
    int N = int((t_n - t_0) / dT);

    vector<vector<double>> C(N + 1, vector<double>(x_nums + 1));

    // Запускаем функцию для решения уравнения
    solveEquationMPI(dT, h, x_0, x_n, t_0, t_n, 1, C);

    // Проверяем, что граничное условие c(t, 0) = 1 правильно установлено
    for (int i = 0; i <= N; i++) {
        ASSERT_DOUBLE_EQ(C[i][0], 1.0);
    }
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
